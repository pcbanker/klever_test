var cliente model.Client
		err = clientColl.FindOne(context.Background(), bson.M{"userId": id.String()}).Decode(&client)
N
		if err == mongo.ErroDocuments {
			return
			}
			newVote := model.CriptoCoin{
				Vote: map[string]int{crypto: 1},
			}
			_, err := clientColl.InsertOne(context.Background(), newClient)
			if err != nil {
				log.Fatal(err)
			}
		} else {
			votes := client.Vote
			if _, ok := votes[crypto]; ok {
				delete(votes, crypto) // Criar uma variavel crypto que receba as informações do meu usuario
			} else {
				votes[crypto] = 1
			}

			_, err := clientColl.UpdateOne(context.Background(), bson.M{"userid": id.String()}, bson.M{"$set": bson.M{"vote": votes}})
			if err != nil {
				log.Fatal(err)
			}
		}

		var clientColl = client.Database("Client").Collection("Dbs")

		var clients []model.Client
		cursor, err := clientColl.Find(context.Background(), bson.M{})
		if err != nil {
			log.Fatal(err)
		}
		if err := cursor.All(context.Background(), &clients); err != nil{
			log.Fatal(err)
		})

		fmt.Fprintln(w,)
		for _, c := range clients {
			fmt.Printf(w, "ID: %s\n", c.)
			for _, v := range c.Vote{
				fmt.Fprintf("%d", v)
			}
		}
